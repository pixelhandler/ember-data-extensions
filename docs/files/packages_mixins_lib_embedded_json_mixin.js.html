<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>packages/mixins/lib/embedded_json_mixin.js - Extensions for Ember Data</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Extensions for Ember Data"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0-beta.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/DS.EmbeddedJSONAdapter.html">DS.EmbeddedJSONAdapter</a></li>
            
                <li><a href="../classes/DS.EmbeddedJSONMixin.html">DS.EmbeddedJSONMixin</a></li>
            
                <li><a href="../classes/DS.EmbeddedJSONSerializer.html">DS.EmbeddedJSONSerializer</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/embedded-json-adapter.html">embedded-json-adapter</a></li>
            
                <li><a href="../modules/ember-data.html">ember-data</a></li>
            
                <li><a href="../modules/mixins.html">mixins</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: packages/mixins/lib/embedded_json_mixin.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(Ember, DS) {

var get = Ember.get;
var forEach = Ember.EnumerableUtils.forEach;

/**
  @module ember-data
  @submodule mixins
**/

/**
  The EmbeddedJSONMixin allows you to add embedded record support to your serializers.

  To set up embedded records, you include the mixin into the serializer and then
  define your embedded relations. The EmbeddedJSONSerializer is an example.

  Below is an example of a per type serializer (post type).

  &#x60;&#x60;&#x60;js
  App.PostSerializer = DS.RESTSerializer.extend(DS.EmbeddedJSONMixin, {
    attrs: {
      author: {embedded: &#x27;always&#x27;},
      comments: {embedded: &#x27;always&#x27;}
    }
  })
  &#x60;&#x60;&#x60;

  Currently only &#x60;{embedded: &#x27;always&#x27;}&#x60; records are supported.

  @class EmbeddedJSONMixin
  @namespace DS
*/
DS.EmbeddedJSONMixin = Ember.Mixin.create({

  /**
    Serialize &#x60;belongsTo&#x60; relationship when it is configured as an embedded object.

    This example of an author model belongs to a post model:

    &#x60;&#x60;&#x60;js
    Post = DS.Model.extend({
      title:    DS.attr(&#x27;string&#x27;),
      body:     DS.attr(&#x27;string&#x27;),
      author:   DS.belongsTo(&#x27;author&#x27;)
    });

    Author = DS.Model.extend({
      name:     DS.attr(&#x27;string&#x27;),
      post:     DS.belongsTo(&#x27;post&#x27;)
    });
    &#x60;&#x60;&#x60;

    Use a custom (type) serializer for the post model to configure embedded author

    &#x60;&#x60;&#x60;js
    App.PostSerializer = DS.RESTSerializer.extend(DS.EmbeddedJSONMixin, {
      attrs: {
        author: {embedded: &#x27;always&#x27;}
      }
    })
    &#x60;&#x60;&#x60;

    A payload with an attribute configured for embedded records can serialize
    the records together under the root attribute&#x27;s payload:

    &#x60;&#x60;&#x60;js
    {
      &quot;post&quot;: {
        &quot;id&quot;: &quot;1&quot;
        &quot;title&quot;: &quot;Rails is omakase&quot;,
        &quot;author&quot;: {
          &quot;id&quot;: &quot;2&quot;
          &quot;name&quot;: &quot;dhh&quot;
        }
      }
    }
    &#x60;&#x60;&#x60;

    @method serializeBelongsTo
    @param {DS.Model} record
    @param {Object} json
    @param relationship
  */
  serializeBelongsTo: function(record, json, relationship) {
    var attr = relationship.key, config = this.get(&#x27;attrs&#x27;);

    if (!config || !isEmbedded(config[attr])) {
      this._super(record, json, relationship);
      return;
    }
    var key = this.keyForAttribute(attr);
    var embeddedRecord = record.get(attr);
    if (!embeddedRecord) {
      json[key] = null;
    } else {
      json[key] = embeddedRecord.serialize();
      var id = embeddedRecord.get(&#x27;id&#x27;);
      if (id) {
        json[key].id = id;
      }
      var parentKey = this.keyForAttribute(relationship.parentType.typeKey);
      if (parentKey) {
        removeId(parentKey, json[key]);
      }
      delete json[key][parentKey];
    }
  },

  /**
    Serialize &#x60;hasMany&#x60; relationship when it is configured as embedded objects.

    This example of a post model has many comments:

    &#x60;&#x60;&#x60;js
    Post = DS.Model.extend({
      title:    DS.attr(&#x27;string&#x27;),
      body:     DS.attr(&#x27;string&#x27;),
      comments: DS.hasMany(&#x27;comment&#x27;)
    });

    Comment = DS.Model.extend({
      body:     DS.attr(&#x27;string&#x27;),
      post:     DS.belongsTo(&#x27;post&#x27;)
    });
    &#x60;&#x60;&#x60;

    Use a custom (type) serializer for the post model to configure embedded comments

    &#x60;&#x60;&#x60;js
    App.PostSerializer = DS.RESTSerializer.extend(DS.EmbeddedJSONMixin, {
      attrs: {
        comments: {embedded: &#x27;always&#x27;}
      }
    })
    &#x60;&#x60;&#x60;

    A payload with an attribute configured for embedded records can serialize
    the records together under the root attribute&#x27;s payload:

    &#x60;&#x60;&#x60;js
    {
      &quot;post&quot;: {
        &quot;id&quot;: &quot;1&quot;
        &quot;title&quot;: &quot;Rails is omakase&quot;,
        &quot;body&quot;: &quot;I want this for my ORM, I want that for my template language...&quot;
        &quot;comments&quot;: [{
          &quot;id&quot;: &quot;1&quot;,
          &quot;body&quot;: &quot;Rails is unagi&quot;
        }, {
          &quot;id&quot;: &quot;2&quot;,
          &quot;body&quot;: &quot;Omakase O_o&quot;
        }]
      }
    }
    &#x60;&#x60;&#x60;

    @method serializeHasMany
    @param {DS.Model} record
    @param {Object} json
    @param relationship
  */
  serializeHasMany: function(record, json, relationship) {
    var attr = relationship.key, config = this.get(&#x27;attrs&#x27;);

    if (!config || !isEmbedded(config[attr])) {
      this._super(record, json, relationship);
      return;
    }
    var key = this.keyForAttribute(attr);
    json[key] = get(record, attr).map(function(relation) {
      var data = relation.serialize(),
          primaryKey = get(this, &#x27;primaryKey&#x27;);

      data[primaryKey] = get(relation, primaryKey);
      if (data.id === null) {
        delete data.id;
      }
      return data;
    }, this);
  },

  /**
    Extract an embedded object from the payload for a single object
    and add the object in the compound document (side-loaded) format instead.

    A payload with an attribute configured for embedded records needs to be extracted:

    &#x60;&#x60;&#x60;js
    {
      &quot;post&quot;: {
        &quot;id&quot;: 1
        &quot;title&quot;: &quot;Rails is omakase&quot;,
        &quot;author&quot;: {
          &quot;id&quot;: 2
          &quot;name&quot;: &quot;dhh&quot;
        }
        &quot;comments&quot;: []
      }
    }
    &#x60;&#x60;&#x60;

    Ember Data is expecting a payload with a compound document (side-loaded) like:

    &#x60;&#x60;&#x60;js
    {
      &quot;post&quot;: {
        &quot;id&quot;: &quot;1&quot;
        &quot;title&quot;: &quot;Rails is omakase&quot;,
        &quot;author&quot;: &quot;2&quot;
        &quot;comments&quot;: []
      },
      &quot;authors&quot;: [{
        &quot;id&quot;: &quot;2&quot;
        &quot;post&quot;: &quot;1&quot;
        &quot;name&quot;: &quot;dhh&quot;
      }]
      &quot;comments&quot;: []
    }
    &#x60;&#x60;&#x60;

    The payload&#x27;s &#x60;author&#x60; attribute represents an object with a &#x60;belongsTo&#x60; relationship.
    The &#x60;post&#x60; attribute under &#x60;author&#x60; is the foreign key with the id for the post

    @method extractSingle
    @param {DS.Store} store
    @param {subclass of DS.Model} primaryType
    @param {Object} payload
    @param {String} recordId
    @param {&#x27;find&#x27;|&#x27;createRecord&#x27;|&#x27;updateRecord&#x27;|&#x27;deleteRecord&#x27;} requestType
    @return Object the primary response to the original request
  */
  extractSingle: function(store, primaryType, payload, recordId, requestType) {
    var root = this.keyForAttribute(primaryType.typeKey),
        partial = payload[root];

    updatePayloadWithEmbedded.call(this, store, primaryType, payload, partial);

    return this._super(store, primaryType, payload, recordId, requestType);
  },

  /**
    Extract embedded objects in an array when an attr is configured for embedded,
    and add them as side-loaded objects instead.

    A payload with an attr configured for embedded records needs to be extracted:

    &#x60;&#x60;&#x60;js
    {
      &quot;post&quot;: {
        &quot;id&quot;: &quot;1&quot;
        &quot;title&quot;: &quot;Rails is omakase&quot;,
        &quot;comments&quot;: [{
          &quot;id&quot;: &quot;1&quot;,
          &quot;body&quot;: &quot;Rails is unagi&quot;
        }, {
          &quot;id&quot;: &quot;2&quot;,
          &quot;body&quot;: &quot;Omakase O_o&quot;
        }]
      }
    }
    &#x60;&#x60;&#x60;

    Ember Data is expecting a payload with compound document (side-loaded) like:

    &#x60;&#x60;&#x60;js
    {
      &quot;post&quot;: {
        &quot;id&quot;: &quot;1&quot;
        &quot;title&quot;: &quot;Rails is omakase&quot;,
        &quot;comments&quot;: [&quot;1&quot;, &quot;2&quot;]
      },
      &quot;comments&quot;: [{
        &quot;id&quot;: &quot;1&quot;,
        &quot;body&quot;: &quot;Rails is unagi&quot;
      }, {
        &quot;id&quot;: &quot;2&quot;,
        &quot;body&quot;: &quot;Omakase O_o&quot;
      }]
    }
    &#x60;&#x60;&#x60;

    The payload&#x27;s &#x60;comments&#x60; attribute represents records in a &#x60;hasMany&#x60; relationship

    @method extractArray
    @param {DS.Store} store
    @param {subclass of DS.Model} primaryType
    @param {Object} payload
    @return {Array&lt;Object&gt;} The primary array that was returned in response
      to the original query.
  */
  extractArray: function(store, primaryType, payload) {
    var root = this.keyForAttribute(primaryType.typeKey),
        partials = payload[Ember.String.pluralize(root)];

    forEach(partials, function(partial) {
      updatePayloadWithEmbedded.call(this, store, primaryType, payload, partial);
    }, this);

    return this._super(store, primaryType, payload);
  }
});

// checks config for embedded flag
function isEmbedded(config) {
  return config &amp;&amp; (config.embedded === &#x27;always&#x27; || config.embedded === &#x27;load&#x27;);
}

// used to remove id (foreign key) when embedding
function removeId(key, json) {
  var idKey = key + &#x27;_id&#x27;;
  if (json.hasOwnProperty(idKey)) {
    delete json[idKey];
  }
}

// chooses a relationship kind to branch which function is used to update payload
// does not change payload if attr is not embedded
function updatePayloadWithEmbedded(store, type, payload, partial) {
  var attrs = get(this, &#x27;attrs&#x27;);

  if (!attrs) {
    return;
  }
  type.eachRelationship(function(key, relationship) {
    var config = attrs[key];

    if (isEmbedded(config)) {
      if (relationship.kind === &quot;hasMany&quot;) {
        updatePayloadWithEmbeddedHasMany.call(this, store, key, relationship, payload, partial);
      }
      if (relationship.kind === &quot;belongsTo&quot;) {
        updatePayloadWithEmbeddedBelongsTo.call(this, store, key, relationship, payload, partial);
      }
    }
  }, this);
}

// handles embedding for &#x60;hasMany&#x60; relationship
function updatePayloadWithEmbeddedHasMany(store, primaryType, relationship, payload, partial) {
  var serializer = store.serializerFor(relationship.type.typeKey),
      primaryKey = get(this, &#x27;primaryKey&#x27;);

  // underscore forces the embedded records to be side loaded.
  // it is needed when main type === relationship.type
  var embeddedTypeKey = &#x27;_&#x27; + Ember.String.pluralize(relationship.type.typeKey);
  var expandedKey = this.keyForRelationship(primaryType, relationship.kind);
  var attribute  = this.keyForAttribute(primaryType);
  var ids = [];

  if (!partial[attribute]) {
    return;
  }

  payload[embeddedTypeKey] = payload[embeddedTypeKey] || [];

  forEach(partial[attribute], function(data) {
    var embeddedType = store.modelFor(relationship.type.typeKey);
    updatePayloadWithEmbedded.call(serializer, store, embeddedType, payload, data);
    ids.push(data[primaryKey]);
    payload[embeddedTypeKey].push(data);
  });

  partial[expandedKey] = ids;
  delete partial[attribute];
}

// handles embedding for &#x60;belongsTo&#x60; relationship
function updatePayloadWithEmbeddedBelongsTo(store, primaryType, relationship, payload, partial) {
  var attrs = this.get(&#x27;attrs&#x27;);

  if (!attrs ||
    !(isEmbedded(attrs[Ember.String.camelize(primaryType)]) || isEmbedded(attrs[primaryType]))) {
    return;
  }
  var serializer = store.serializerFor(relationship.type.typeKey),
      primaryKey = get(serializer, &#x27;primaryKey&#x27;),
      embeddedTypeKey = Ember.String.pluralize(relationship.type.typeKey),
      expandedKey = serializer.keyForRelationship(primaryType, relationship.kind),
      attribute = serializer.keyForAttribute(primaryType);

  if (!partial[attribute]) {
    return;
  }
  payload[embeddedTypeKey] = payload[embeddedTypeKey] || [];
  var embeddedType = store.modelFor(relationship.type.typeKey);
  partial[expandedKey] = partial[attribute].id;
  // Need to move an embedded &#x60;belongsTo&#x60; object into a pluralized collection
  payload[embeddedTypeKey].push(partial[attribute]);
  // Need a reference to the parent so relationship works between both &#x60;belongsTo&#x60; records
  partial[attribute][relationship.parentType.typeKey + &#x27;_id&#x27;] = partial.id;
  delete partial[attribute];
}

}(Ember, DS));

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
